//#include "screen模拟实现的头文件.h"

//int main()
//{
//	Screen s1( 10 , 20 , 'c' );
//	char c = s1.get();
//	printf("%c\n" , c );
//
//	s1.i = 100;  //  外部只能访问 类  public 区域内的成员变量
//	printf("%d\n", s1.i );
//
//	//这里的s2也是 局部变量
//	Screen s2;
//	s2 = s1.move(0,3);
//	char c2 = s2.get();
//	cout << "c2   " << c2 << endl;
//
//	s1.Change_content('a');
//	cout << s1.get() << endl;
//
//	cout << s1.get(0, 3) << endl ;
//	s1.Change_content2(0,3,'a');
//	cout << s1.get(0, 3) << endl;
//
//	cout << s1.get(0, 4) << endl;
//	s1.move(0, 4).Change_content2(0, 4, '!');
//	cout << "看这里有无变化，原先是 '!'     " << s1.get(0, 4) << endl;
//
//	// 前后改变了  两次  一次是Change_content2     一次是改变move
//	// 删去Change_content2 的 & 时 并不影响改值   ，目测是因为 字符串赋值，里边用的是指针，是地址，传的是地址，所以不影响
//	// 删去move 里边 & 时 ，光标已经无法改变，因为这是一个临时拷贝的变量， 改变这个变量里的值，不影响 对象 里的变量
//
//	//*************************************************************************************************************************************
//	//**********************************  重点！ 当使用类区域 存在 this 的时候，这里的 & 不仅仅修饰返回值   *******************************
//	//**********************************  如果没有 & 引用标志 ,函数大概会 再创造这样一个类 ，再用this* 指针指向这个类  ********************
//	//*************************************************************************************************************************************
//
//	cout << s1.get(0, 4) << endl;
//	s1.move(0, 4).Change_content( '#');  //这里是  函数的连用 超级酷！
//	cout << s1.get() << endl;
//
//	//    对字符串的遍历
//	for (size_t i = 0; s1.get() != 0; i++)
//	{
//		s1.move(0, i);
//		cout << s1.get() << " ";
//
//	}
//	cout << endl;
//
//	return 0;
//}











